<!DOCTYPE html>
<html lang="en">
  <head>
    <title>folds</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        color: #ffffff;
        font-family:Monospace;
        font-size:13px;
        text-align:center;
        font-weight: bold;
        background-color: #000000;
        margin: 0px;
        overflow: hidden;
      }
    </style>
  </head>

  <body>
    <div id="container"></div>

    <script src="./three.js"></script>

    <script type="x-shader/x-vertex" id="paperVertexShader">
      attribute vec3 aDisplacement;

      uniform float amplitude;
      uniform float uShouldDistort;

      varying vec2 vUV;
      varying vec3 vPosition;

      void main() {
        vUV = uv;

        vec3 newPosition = position + aDisplacement;// + amplitude * normal * vec3(aDisplacement);

        vPosition = newPosition;
        if (uShouldDistort < 0.5) {
          newPosition = position;
        }

        gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
      }
    </script>

    <script type="x-shader/x-fragment" id="paperFragmentShader">
      // TODO: FINISH THIS!!!
      const float AMBIENT_INTENSITY = 0.3;
      const float DIRECTIONAL_INTENSITY = 0.7;
      const vec3 DIRECTION = vec3(1.0, 0.0, 0.0);

      uniform sampler2D uSource;

      varying vec2 vUV;
      varying vec3 vPosition;

      void main() {
        vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));
        float directionalIntensity = DIRECTIONAL_INTENSITY * (dot(normal, DIRECTION) * 0.5 + 0.5);

        vec4 color = texture2D(uSource, vUV);

        gl_FragColor = vec4(mix(vec3(0.0), color.xyz, AMBIENT_INTENSITY + directionalIntensity), 1.0);
      }
    </script>

    <script type="x-shader/x-fragment" id="normalsFragmentShader">
      varying vec2 vUV;
      varying vec3 vPosition;

      void main() {
        vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));
        normal = normal * 0.5 + 0.5;
        gl_FragColor = vec4(normal, 1.0);
      }
    </script>

    <script type="x-shader/x-fragment" id="edgesFragmentShader">
      uniform vec2 uInverseResolution;
      uniform sampler2D uNormals;

      varying vec2 vUV;

      void main() {
        // TODO: look at 8direction?
        // TODO: check for inversion/winding? (when you crumple, verts can go by each other)
        vec2 offsetX = vec2(1.0 * uInverseResolution.x, 0.0);
        vec2 offsetY = vec2(0.0, 1.0 * uInverseResolution.y);
        vec3 normalC = normalize(texture2D(uNormals, vUV).xyz * 2.0 - 1.0);
        vec3 normalN = normalize(texture2D(uNormals, vUV - offsetY).xyz * 2.0 - 1.0);
        vec3 normalS = normalize(texture2D(uNormals, vUV + offsetY).xyz * 2.0 - 1.0);
        vec3 normalE = normalize(texture2D(uNormals, vUV + offsetX).xyz * 2.0 - 1.0);
        vec3 normalW = normalize(texture2D(uNormals, vUV - offsetX).xyz * 2.0 - 1.0);
        float accel = min(min(min(dot(normalC, normalN), dot(normalC, normalS)), dot(normalC, normalE)), dot(normalC, normalW));
        accel = accel * -0.5 + 0.5;

        gl_FragColor = vec4(accel);
      }
    </script>

    <script type="x-shader/x-vertex" id="fullScreenQuadVertexShader">
      varying vec2 vUV;

      void main() {
        vUV = uv;
        gl_Position = vec4(position, 1.0);
      }
    </script>

    <script type="x-shader/x-fragment" id="blurFragmentShader">
      uniform vec2 uInverseResolution;
      uniform vec2 uDir;
      uniform sampler2D uSource;

      varying vec2 vUV;

      void main() {
        // REF: http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/
        vec4 sum = vec4(0.0);
        sum += texture2D(uSource, vUV) * 0.2270270270;
        sum += texture2D(uSource, vUV + uInverseResolution * uDir * 1.3846153846) * 0.3162162162;
        sum += texture2D(uSource, vUV - uInverseResolution * uDir * 1.3846153846) * 0.3162162162;
        sum += texture2D(uSource, vUV + uInverseResolution * uDir * 3.2307692308) * 0.0702702703;
        sum += texture2D(uSource, vUV - uInverseResolution * uDir * 3.2307692308) * 0.0702702703;
        gl_FragColor = sum;
      }
    </script>

    <script type="x-shader/x-fragment" id="displayTextureFragmentShader">
      uniform sampler2D uSource;

      varying vec2 vUV;

      void main() {
        gl_FragColor = texture2D(uSource, vUV);
      }
    </script>

    <script type="x-shader/x-fragment" id="displayUVFragmentShader">
      varying vec2 vUV;

      void main() {
        gl_FragColor = vec4(vUV.x, 0.0, vUV.y, 1.0);
      }
    </script>


    <script>
    // REF: https://threejs.org/examples/#webgl_custom_attributes

    // NUMBERS
    var PAPER_SIZE = 120;
    var PAPER_SEGMENTS = 200;
    var HALF_PAPER_SIZE = PAPER_SIZE / 2;

    // ANIMATION
    var paperGeometry, displacement, startDisplacement, endDisplacement, animationStartTime, isAnimating, isFolding;
    var inputState = {
      lastEventRay: new THREE.Vector3(),
      lastMouseDownPosition: new THREE.Vector3(),
      lastMouseUpPosition: new THREE.Vector3()
    };

    // RENDERING
    var renderer;
    var paperMesh, paperScene, paperOrthoCamera, paperPerspectiveCamera;
    var fullScreenQuadMesh, fullScreenQuadScene, fullScreenQuadOrthoCamera;
    var normalsPassMaterial, edgesPassMaterial, blurPassMaterial; // texture accumulation pass(es), paper final pass
    var tempTargetA, tempTargetB, foldAccumulationTarget;

    // CONSTANTS
    // TODO: put these somewhere
    var HORIZONTAL_DIR = new THREE.Vector2(1, 0);
    var VERTICAL_DIR = new THREE.Vector2(0, 1);

    init();
    tick();

    function init() {

      // CAMERAS /////////////////////////////////////////////////
      paperOrthoCamera = new THREE.OrthographicCamera(-HALF_PAPER_SIZE, HALF_PAPER_SIZE, HALF_PAPER_SIZE, -HALF_PAPER_SIZE, 1, 10000);
      paperOrthoCamera.position.z = 300;

      paperPerspectiveCamera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 10000);
      paperPerspectiveCamera.position.z = 300;

      fullScreenQuadOrthoCamera = new THREE.OrthographicCamera();
      // CAMERAS /////////////////////////////////////////////////

      // SCENES //////////////////////////////////////////////////
      paperScene = new THREE.Scene();
      fullScreenQuadScene = new THREE.Scene();
      // SCENES //////////////////////////////////////////////////




      // TARGETS /////////////////////////////////////////////////
      // TODO: Do these need to not be linear when we're not doing blur?
      tempTargetA = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, { magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter });
      tempTargetB = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, { magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter });
      foldAccumulationTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, { magFilter: THREE.NearestFilter, minFilter: THREE.NearestFilter });
      // TARGETS /////////////////////////////////////////////////



      // MATERIALS ///////////////////////////////////////////////
      normalsPassMaterial = new THREE.ShaderMaterial({
        uniforms: {
          amplitude: { value: 1.0 },
          uShouldDistort: { value: 0.0 },
        },
        vertexShader:document.getElementById('paperVertexShader').textContent,
        fragmentShader: document.getElementById('normalsFragmentShader').textContent,
        extensions: {
          derivatives: true
        }
      });

      edgesPassMaterial = new THREE.ShaderMaterial({
        uniforms: {
          uInverseResolution: { value: new THREE.Vector2(1 / window.innerWidth, 1 / window.innerHeight) },
          uNormals: { value: tempTargetA.texture }
        },
        vertexShader:document.getElementById('fullScreenQuadVertexShader').textContent,
        fragmentShader: document.getElementById('edgesFragmentShader').textContent
      });

      blurPassMaterial = new THREE.ShaderMaterial({
        uniforms: {
          uInverseResolution: { value: new THREE.Vector2(1 / window.innerWidth, 1 / window.innerHeight) },
          uDir: { value: new THREE.Vector2(1, 0) },
          uSource: { value: tempTargetB.texture }
        },
        vertexShader: document.getElementById('fullScreenQuadVertexShader').textContent,
        fragmentShader: document.getElementById('blurFragmentShader').textContent
      });

      uvPassMaterial = new THREE.ShaderMaterial({
        uniforms: {
        },
        vertexShader: document.getElementById('fullScreenQuadVertexShader').textContent,
        fragmentShader: document.getElementById('displayUVFragmentShader').textContent
      });

      foldPassMaterial = new THREE.ShaderMaterial({
        uniforms: {
          uSource: { value: foldAccumulationTarget.texture }
        },
        vertexShader: document.getElementById('fullScreenQuadVertexShader').textContent,
        fragmentShader: document.getElementById('displayTextureFragmentShader').textContent,
        blending: THREE.AdditiveBlending
      });

      paperPassMaterial = new THREE.ShaderMaterial({
        uniforms: {
          amplitude: { value: 1.0 },
          uShouldDistort: { value: 1.0 },
          uSource: { value: tempTargetA.texture }
        },
        vertexShader: document.getElementById('paperVertexShader').textContent,
        fragmentShader: document.getElementById('paperFragmentShader').textContent,
        extensions: {
          derivatives: true
        },
        side: THREE.DoubleSide
      });
      // MATERIALS ///////////////////////////////////////////////



      // MESHES //////////////////////////////////////////////////
      paperGeometry = new THREE.PlaneBufferGeometry(PAPER_SIZE, PAPER_SIZE, PAPER_SEGMENTS, PAPER_SEGMENTS);
      displacement = new Float32Array(paperGeometry.attributes.position.count * 3); // For animation
      startDisplacement = new Float32Array(paperGeometry.attributes.position.count * 3); // For calculation
      endDisplacement = new Float32Array(paperGeometry.attributes.position.count * 3); // For calculation
      paperGeometry.addAttribute('aDisplacement', new THREE.BufferAttribute(displacement, 3));
      paperMesh = new THREE.Mesh(paperGeometry, normalsPassMaterial);
      paperScene.add(paperMesh);

      fullScreenQuadMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), edgesPassMaterial);
      fullScreenQuadScene.add(fullScreenQuadMesh);
      // MESHES //////////////////////////////////////////////////



      // RENDERER ETC ////////////////////////////////////////////
      renderer = new THREE.WebGLRenderer();
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      var container = document.getElementById('container');
      container.appendChild(renderer.domElement);
      window.addEventListener('resize', onWindowResize, false);
      // RENDERER ETC ////////////////////////////////////////////
    }



    function onWindowResize() {
      // Cameras
      paperPerspectiveCamera.aspect = window.innerWidth / window.innerHeight;
      paperPerspectiveCamera.updateProjectionMatrix();
      paperOrthoCamera.aspect = window.innerWidth / window.innerHeight;
      paperOrthoCamera.updateProjectionMatrix();
      fullScreenQuadOrthoCamera.aspect = window.innerWidth / window.innerHeight;
      fullScreenQuadOrthoCamera.updateProjectionMatrix();

      // Targets
      tempTargetA.setSize(window.innerWidth, window.innerHeight);
      tempTargetB.setSize(window.innerWidth, window.innerHeight);
      foldAccumulationTarget.setSize(window.innerWidth, window.innerHeight);

      // Uniforms
      edgesPassMaterial.uniforms.uInverseResolution.value = new THREE.Vector2(1 / window.innerWidth, 1 / window.innerHeight);
      blurPassMaterial.uniforms.uInverseResolution.value = new THREE.Vector2(1 / window.innerWidth, 1 / window.innerHeight);

      // Renderer
      renderer.setSize(window.innerWidth, window.innerHeight);
    }






    function tick() {
      requestAnimationFrame(tick);
      animate();
      render();
    }





    function trackEventPosition(stateProperty, evt) {
      // REF: https://stackoverflow.com/questions/13055214/mouse-canvas-x-y-to-three-js-world-x-y-z
      inputState.lastEventRay.set((evt.clientX / window.innerWidth) * 2 - 1, -(evt.clientY / window.innerHeight) * 2 + 1, 0.5);
      inputState.lastEventRay.unproject(paperPerspectiveCamera);
      inputState.lastEventRay.sub(paperPerspectiveCamera.position).normalize();
      var distanceToZPlane = -paperPerspectiveCamera.position.z / inputState.lastEventRay.z;
      inputState[stateProperty].copy(paperPerspectiveCamera.position).add(inputState.lastEventRay.multiplyScalar(distanceToZPlane));
    }

    // TODO: find a home for these
    var paperPos = new THREE.Vector3();
    var foldVec = new THREE.Vector3();
    var tempVec1 = new THREE.Vector3();
    var tempVec2 = new THREE.Vector3();
    function fold() {
      // REF: https://math.stackexchange.com/questions/65503/point-reflection-over-a-line
      foldVec.copy(inputState.lastMouseUpPosition).sub(inputState.lastMouseDownPosition)
      // TODO: name these better?
      var a = (foldVec.x * foldVec.x - foldVec.y * foldVec.y) / (foldVec.x * foldVec.x + foldVec.y * foldVec.y);
      var b = 2 * foldVec.x * foldVec.y / (foldVec.x * foldVec.x + foldVec.y * foldVec.y);

      for (var i = 0; i < (displacement.length - 2); i += 3) {
        // Reset start and end displacements
        startDisplacement[i + 0] = endDisplacement[i + 0];
        startDisplacement[i + 1] = endDisplacement[i + 1];
        startDisplacement[i + 2] = endDisplacement[i + 2];

        // Get current paper position
        paperPos.set(paperGeometry.attributes.position.array[i + 0] + startDisplacement[i + 0],
                     paperGeometry.attributes.position.array[i + 1] + startDisplacement[i + 1],
                     paperGeometry.attributes.position.array[i + 2] + startDisplacement[i + 2]);

        // Check winding
        tempVec1.copy(foldVec).cross(tempVec2.copy(paperPos).sub(inputState.lastMouseDownPosition));
        if (tempVec1.z > 0) {
          // Flip one side
          var newX = a * (paperPos.x - inputState.lastMouseDownPosition.x) + b * (paperPos.y - inputState.lastMouseDownPosition.y) + inputState.lastMouseDownPosition.x;
          var newY = b * (paperPos.x - inputState.lastMouseDownPosition.x) - a * (paperPos.y - inputState.lastMouseDownPosition.y) + inputState.lastMouseDownPosition.y;
          endDisplacement[i + 0] += newX - paperPos.x;
          endDisplacement[i + 1] += newY - paperPos.y;
          endDisplacement[i + 2] += 0.1; // TODO: HOW TO ACCUMULATE DEPTH???
        }
      }
      startAnimating('fold');
    }

    function crumple(evt) {

    }

    function unfold(evt) {
      if (evt.key !== ' ') return;
      for (var i = 0; i < (displacement.length - 2); i += 3) {
        startDisplacement[i + 0] = endDisplacement[i + 0];
        startDisplacement[i + 1] = endDisplacement[i + 1];
        startDisplacement[i + 2] = endDisplacement[i + 2];
        endDisplacement[i + 0] = 0;
        endDisplacement[i + 1] = 0;
        endDisplacement[i + 2] = 0;
      }
      startAnimating('fold');
    }

    // TODO: VISUALIZE THESE
    // TODO: REFACTOR EVERYTHING
    window.addEventListener('mousedown', trackEventPosition.bind(null, 'lastMouseDownPosition'));
    window.addEventListener('mouseup', trackEventPosition.bind(null, 'lastMouseUpPosition'));
    window.addEventListener('mouseup', fold);
    window.addEventListener('keypress', unfold);






    function startAnimating(animation) {
      animationStartTime = Date.now();
      isAnimating = true;
      switch(animation) {
        case 'fold':
          isFolding = true;
          return;
        default:
          isAnimating = false;
          return;
      }
    }

    function animate() {
      if (!isAnimating) return

      var dt = (Date.now() - animationStartTime) * 0.001;
      if (dt > 1) {
        isAnimating = false;
      }

      if (isFolding) {
        var angle = Math.PI * dt;
        var horizontalProgress = -Math.cos(angle) * 0.5 + 0.5;
        var verticalProgress = Math.sin(angle);
        console.log(dt, horizontalProgress, verticalProgress);
        for (var i = 0; i < (displacement.length - 2); i += 3) {
          var dx = endDisplacement[i + 0] - startDisplacement[i + 0];
          var dy = endDisplacement[i + 1] - startDisplacement[i + 1];
          var dz = Math.sqrt(dx * dx * 0.25 + dy * dy * 0.25);
          displacement[i + 0] = isAnimating ? startDisplacement[i + 0] + horizontalProgress * dx : endDisplacement[i + 0];
          displacement[i + 1] = isAnimating ? startDisplacement[i + 1] + horizontalProgress * dy : endDisplacement[i + 1];
          displacement[i + 2] = isAnimating ? verticalProgress * dz : endDisplacement[i + 2];
        }
      }

      if (!isAnimating) {
        isFolding = false;
      }

      paperMesh.geometry.attributes.aDisplacement.needsUpdate = true;
    }





    function render() {
      // Setup
      renderer.setClearColor(new THREE.Color(0x000000), 0);
      renderer.autoClear = false; // TODO: do this outside of the render loop?

      // Passes
      paperMesh.material = normalsPassMaterial;
      renderer.render(paperScene, paperOrthoCamera, tempTargetA, true);

      fullScreenQuadMesh.material = edgesPassMaterial;
      edgesPassMaterial.uniforms.uNormals.value = tempTargetA.texture;
      renderer.render(fullScreenQuadScene, fullScreenQuadOrthoCamera, tempTargetB, true);

      fullScreenQuadMesh.material = blurPassMaterial;
      blurPassMaterial.uniforms.uDir.value = HORIZONTAL_DIR;
      blurPassMaterial.uniforms.uSource.value = tempTargetB.texture;
      blurPassMaterial.blending = THREE.NoBlending;
      renderer.render(fullScreenQuadScene, fullScreenQuadOrthoCamera, tempTargetA, true);

      fullScreenQuadMesh.material = blurPassMaterial;
      blurPassMaterial.uniforms.uDir.value = VERTICAL_DIR;
      blurPassMaterial.uniforms.uSource.value = tempTargetA.texture;
      blurPassMaterial.blending = THREE.CustomBlending;
      blurPassMaterial.blendEquation = THREE.MaxEquation;
      blurPassMaterial.blendSrc = THREE.OneFactor;
      blurPassMaterial.blendDst = THREE.OneFactor;
      renderer.render(fullScreenQuadScene, fullScreenQuadOrthoCamera, foldAccumulationTarget, false);

      // Next youre going to render the second blur pass onto the fold accumulator target
      // then add that target to the paper texture and use the result as the texture
      // for simple phong (or something) rendering of the paper.
      // Could also pass in the fold accumulation in addition to the main texture to the paper renderer.

      // Cool so this is all more or less working only the blending isn't working
      // So next make sure you're clearing to the right colors and doing blending right

      // Okay you got blending working between the base image (in this case the uv pass) and the folds
      // Next you need to actually accumulate the folds onto the fold target accumulation target
      // You're dynamically setting autoClear and material blending mode but it's still not working

      // Alright so you got accumulation working, but it looks kinda weird.
      // I think you need a blend mode that does like a max instead of add? Is that a thing?
      // It is! I guess next is to fix the movement?

      // TODO
      // Next steps:
      // [ ] Antialias folds
      // [ ] Replace UV with pic?

      fullScreenQuadMesh.material = uvPassMaterial;
      renderer.render(fullScreenQuadScene, fullScreenQuadOrthoCamera, tempTargetA, true);

      fullScreenQuadMesh.material = foldPassMaterial;
      foldPassMaterial.uniforms.uSource.value = foldAccumulationTarget.texture;
      renderer.render(fullScreenQuadScene, fullScreenQuadOrthoCamera, tempTargetA, false);

      paperMesh.material = paperPassMaterial;
      paperPassMaterial.uniforms.uSource.value = tempTargetA.texture;
      renderer.setClearColor(new THREE.Color(0x000000), 1);
      renderer.render(paperScene, paperPerspectiveCamera, null, true);
    }
  </script>

</body>

</html>